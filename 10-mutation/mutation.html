<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Mutation (BCFAE) - Programming Languages I</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Lecture notes for the Programming Languages I lecture at the University of TÃ¼bingen">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../preface.html">Preface</a></li><li class="chapter-item expanded affix "><li class="part-title">Introduction</li><li class="chapter-item expanded "><a href="../01-intro/intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../02-scala-basics/scala-basics.html"><strong aria-hidden="true">2.</strong> Scala Basics</a></li><li class="chapter-item expanded affix "><li class="part-title">Arithmetic Expressions</li><li class="chapter-item expanded "><a href="../03-arithmetic-expressions/arithmetic-expressions.html"><strong aria-hidden="true">3.</strong> Arithmetic Expressions (AE)</a></li><li class="chapter-item expanded "><a href="../04-desugaring/desugaring.html"><strong aria-hidden="true">4.</strong> Desugaring</a></li><li class="chapter-item expanded "><a href="../05-name-binding/name-binding.html"><strong aria-hidden="true">5.</strong> Name Binding (WAE)</a></li><li class="chapter-item expanded "><a href="../06-first-order-functions/first-order-functions.html"><strong aria-hidden="true">6.</strong> First Order Functions (F1WAE)</a></li><li class="chapter-item expanded "><a href="../07-higher-order-functions/higher-order-functions.html"><strong aria-hidden="true">7.</strong> Higher Order Functions (FAE)</a></li><li class="chapter-item expanded "><a href="../08-lazy-evaluation/lazy-evaluation.html"><strong aria-hidden="true">8.</strong> Lazy Evaluation (LCFAE)</a></li><li class="chapter-item expanded "><a href="../09-recursive-functions/recursive-functions.html"><strong aria-hidden="true">9.</strong> Recursive Functions (RCFAE)</a></li><li class="chapter-item expanded "><a href="../10-mutation/mutation.html" class="active"><strong aria-hidden="true">10.</strong> Mutation (BCFAE)</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Topics 1</li><li class="chapter-item expanded "><a href="../11-garbage-collection/garbage-collection.html"><strong aria-hidden="true">11.</strong> Garbage Collection</a></li><li class="chapter-item expanded "><a href="../12-meta-interpretation/meta-interpretation.html"><strong aria-hidden="true">12.</strong> Syntactic and Meta Interpretation</a></li><li class="chapter-item expanded "><a href="../13-church-encoding/church-encoding.html"><strong aria-hidden="true">13.</strong> Church Encodings</a></li><li class="chapter-item expanded "><a href="../14-object-algebras/object-algebras.html"><strong aria-hidden="true">14.</strong> Object Algebras</a></li><li class="chapter-item expanded affix "><li class="part-title">Continuations</li><li class="chapter-item expanded "><a href="../15-continuations-1/continuations-1.html"><strong aria-hidden="true">15.</strong> Continuations 1</a></li><li class="chapter-item expanded "><a href="../16-continuations-2/continuations-2.html"><strong aria-hidden="true">16.</strong> Continuations 2</a></li><li class="chapter-item expanded "><a href="../17-first-class-continuations/first-class-continuations.html"><strong aria-hidden="true">17.</strong> First Class Continuations</a></li><li class="chapter-item expanded "><a href="../18-letcc/letcc.html"><strong aria-hidden="true">18.</strong> LetCC</a></li><li class="chapter-item expanded "><a href="../19-shift-reset/shift-reset.html"><strong aria-hidden="true">19.</strong> ShiftReset</a></li><li class="chapter-item expanded affix "><li class="part-title">Monads</li><li class="chapter-item expanded "><a href="../20-monads-intro/monads-intro.html"><strong aria-hidden="true">20.</strong> Monads Intro</a></li><li class="chapter-item expanded "><a href="../21-io-monad/io-monad.html"><strong aria-hidden="true">21.</strong> IO Monad</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Topics 2</li><li class="chapter-item expanded "><a href="../22-modular-interpreters/modular-interpreters.html"><strong aria-hidden="true">22.</strong> Modular Interpreters</a></li><li class="chapter-item expanded "><a href="../23-monadic-reflection/monadic-reflection.html"><strong aria-hidden="true">23.</strong> Monadic Reflection</a></li><li class="chapter-item expanded "><a href="../24-defunctionalization/defunctionalization.html"><strong aria-hidden="true">24.</strong> Defunctionalization</a></li><li class="chapter-item expanded affix "><li class="part-title">Type Systems</li><li class="chapter-item expanded "><a href="../25-type-systems/type-systems.html"><strong aria-hidden="true">25.</strong> Type Systems</a></li><li class="chapter-item expanded "><a href="../26-stlc/stlc.html"><strong aria-hidden="true">26.</strong> Simply Typed Lambda Calculus (STLC)</a></li><li class="chapter-item expanded "><a href="../27-type-inference/type-inference.html"><strong aria-hidden="true">27.</strong> Type Inference</a></li><li class="chapter-item expanded affix "><a href="../furtherreading.html">Further Reading</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Programming Languages I</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ps-tuebingen-courses/pl1-lecture-notes" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/ps-tuebingen-courses/pl1-lecture-notes/blob/master/out/10-mutation/mutation.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="mutation"><a class="header" href="#mutation">Mutation</a></h1>
<p>The content of this chapter is available as a scala file <a href="./mutation.scala">here.</a></p>
<pre><code class="language-scala">import scala.language.implicitConversions

/**
Mutation
========
Today we study _mutation_. More specifically, we want to equip our language with mutable data structures.
Typical mutable data structures in common languages include objects with mutable fields or structures/records in languages like C or Pascal.
We will study a particularly simple mutable data structure: Boxes. In OO parlance, boxes can be thought of as an object with
a single field that can be mutated. Despite their simplicity, boxes already illustrate all main issues associated with adding
mutable state to a language.
A different and less interesting form of mutation is the mutability of _variables_, such as the possibility to assign something
to a 'local' variable bound via a lambda or ``with``. We will not talk about mutable variables today.
We will add boxes to our base language, FAE.
*/
object Syntax {
  sealed abstract class Exp
  case class Num(n: Int) extends Exp
  case class Id(name: String) extends Exp
  case class Add(lhs: Exp, rhs: Exp) extends Exp
  case class Mul(lhs: Exp, rhs: Exp) extends Exp
  case class If0(cond: Exp, thenExp: Exp, elseExp: Exp) extends Exp
  implicit def num2exp(n: Int): Exp = Num(n)
  implicit def id2exp(s: String): Exp = Id(s)
  case class Fun(param: String, body: Exp) extends Exp
  case class App (funExpr: Exp, argExpr: Exp) extends Exp
  def wth(x: String, xdef: Exp, body: Exp) : Exp = App(Fun(x,body),xdef)

  /**
  To add mutation to FAE, we add four language constructs:
  */

  case class NewBox(e: Exp) extends Exp // create a new box
  case class SetBox(b: Exp, e: Exp) extends Exp // assign to a box
  case class OpenBox(b: Exp) extends Exp // read value in a box
  case class Seq(e1: Exp, e2: Exp) extends Exp // sequencing of expressions
}
import Syntax._
/**
In this new language, the following sample program,
*/

val test1 = wth(&quot;b&quot;, NewBox(0),
              Seq(
                SetBox(&quot;b&quot;, Add(1, OpenBox(&quot;b&quot;))),
                OpenBox(&quot;b&quot;)))

/**
should give as result ``1`` in a proper implementation.
Let's consider how our interpreter could handle sequencing.
Here is an attempt:
     case Seq(e1, e2) =&gt; {
       eval(e1, env)
       eval(e2, env)
     }
This cannot be correct. As long as our interpreter does not use mutation, evaluation could not make any changes to the environment,
hence there is* no way the evaluation of e1 could have any effect on the evaluation of e2.
In order to demostrate the actual nature of mutation, we will not use mutation in our meta-language to implement mutation
in our object language. That said, we will not use a mutable data structure to implement environment in our interpreter.
Instead, one may turn to the so-called environment-passing style, in which the interpreter returns also a possibly updated environment
together with the computed value when it evaluates an expression.  However, this solution does not always work.  Consider the following
example:
*/

val test2 = wth(&quot;a&quot;, NewBox(1),
              wth(&quot;f&quot;, Fun(&quot;x&quot;, Add(&quot;x&quot;, OpenBox(&quot;a&quot;))),
                Seq(SetBox(&quot;a&quot;,2),
                  App(&quot;f&quot;, 5))))

/**
The mutation should affect the box stored in the closure bound to ``f``.  But with the implementation strategy described above it would not.
Note that changing the value of a in the example is not a vialation of static scope.  Scoping only says where an identifier is bound;
it does not say to what an identifier is bound, in particular, whether whatever bound to the identifier is fixed.
Indeed, the variable a is bound to the same box in both the static environment where the function f is created and the dynamic environment
where the function f is applied.
As before, when applying the function f to the argument 5, we can choose either
   1) To use the static environment (where the variable a is bound to a boxed 1) stored in the closure created for f.
   2) Or to use the dynamic environment (where the variable a is bound to a  boxed 2) present at the time of applying f.
The first choice leads the program to evaluate to 6 rather than the expected 7.  The second will record the change to the box,
but it reintroduces dynamic scoping.  So both choices do not work.
Insight: We need _two_ repositories of information.
One, the environment, guards static scope.
*/

sealed abstract class Value
type Env = Map[String, Value]
case class NumV(n: Int) extends Value
case class ClosureV(f: Fun, env: Env) extends Value

/**
The other, which we call _store_, is trackis dynamic changes.
Determining the value inside a box will become a two-step process: We first evaluate the box expression to an _address_,
and then use the store to lookup the value stored at that address. We choose to represent addresses by integers.
*/

type Address = Int
case class AddressV(a: Address) extends Value

type Store = Map[Address, Value]

/**
We will often need a fresh address in the store. We do so using a counter variable.
*/

var _nextAddress = 0

def nextAddress : Address = {
  _nextAddress += 1
  _nextAddress
}

/**
Note: We promised to implement the interpreter without using mutation. Here we did use mutation, but this musage of mutation
is not essential: we could instead just search for the largest address in the present store and add one to it.
Let's now discuss the evaluation of FAE with conditionals and boxes, BCFAE. To this end, consider the following sample program:
*/

val test3 = wth(&quot;switch&quot;, NewBox(0),
             wth(&quot;toggle&quot;, Fun(&quot;dummy&quot;, If0(OpenBox(&quot;switch&quot;),
                                          Seq(SetBox(&quot;switch&quot;, 1), 1),
                                          Seq(SetBox(&quot;switch&quot;, 0), 0))),
                 Add(App(&quot;toggle&quot;,42), App(&quot;toggle&quot;,42))))

/**
This program should return 1. Let's discuss on the blackboard what the environment and store should look like during the
evaluation of this program.
ID      Exp                     Value   Env             Store
A       wth(..                          &quot;switch&quot; -&gt; ..   1 -&gt; NumV(0)
B        wth(..                         &quot;toggle&quot; -&gt; ..
C         Add(..
D          App(&quot;toggle&quot;)         1                       1 -&gt; NumV(1)
E          App(&quot;toggle&quot;)         0                       1 -&gt; NumV(0)
F         Add(0,1)              1
Insight:
We must pass the current store in to evaluate every expression and pass the possibly updated store out after the evaluation.
This is called _store-passing style:.  Consequently, we have to update the type of our evaluator.
*/

def eval(e: Exp, env: Env, s: Store) : (Value, Store) = e match {
  /* All expressions whose evaluation does not alter the store just return s. */
  case Num(n) =&gt; (NumV(n), s)
  case Id(x) =&gt; (env(x), s)
  case f@Fun(_, _) =&gt; (ClosureV(f, env), s)
  /* In recursive cases we have to thread the store through the
   * evaluation. In particular, we define the order of evaluation
   * explicitly through data flow dependencies.  */
  case If0(cond, thenExp, elseExp)
    =&gt; eval(cond, env, s) match {
         case (NumV(0), s1) =&gt; eval(thenExp, env, s1)
         case (_, s1)       =&gt; eval(elseExp, env, s1)

         /* An alternative that enfoces runtime type-correctness of
          * the conditional expression:
         case (NumV(_), s1) =&gt; eval(elseExp, env, s1)
         case _             =&gt; sys.error(&quot;can only test if a number is 0&quot;) */
       }

  case Add(l, r)
    =&gt; eval(l, env, s) match {
         case (NumV(v1), s1)
           =&gt; eval(r, env, s1) match {
                case (NumV(v2), s2) =&gt; (NumV(v1 + v2), s2)
                case _ =&gt; sys.error(&quot;can only add numbers&quot;)
              }
         case _
           =&gt; sys.error(&quot;can only add numbers&quot;)
       }

  case Mul(l, r)
    =&gt; eval(l, env, s) match {
         case (NumV(v1), s1)
           =&gt; eval(r, env, s1) match {
                case (NumV(v2), s2) =&gt; (NumV(v1 * v2), s2)
                case _ =&gt; sys.error(&quot;can only multiply numbers&quot;)
              }
         case _ =&gt; sys.error(&quot;can only multiply numbers&quot;)
       }

  case App(f, a)
    =&gt; eval(f, env, s) match {
         case (ClosureV(f, closureEnv), s1)
           =&gt; eval(a, env, s1) match {
                case (av, s2)
                  =&gt; eval(f.body, closureEnv + (f.param -&gt; av), s2)
              }
         case _ =&gt; sys.error(&quot;can only apply functions&quot;)
       }

  /* In a sequence, we ignore the result of evaluating e1 but not its
   * effect on the store. */
  case Seq(e1, e2) =&gt; eval(e2, env, eval(e1, env, s)._2)

  /* A new box is created by putting it into the store at a new
   * address.  */
  case NewBox(e: Exp)
    =&gt; eval(e, env, s) match {
         case (v, s1) =&gt; {
           val a = nextAddress
           (AddressV(a), s1 + (a -&gt; v))
         }
       }

  /* Setting a box is now a two-step process: First evaluate b to an
   * address, then lookup and update the value associated to the
   * address in the store. Note that &quot;updated&quot; is a functional method.  */
  case SetBox(b: Exp, e: Exp)
    =&gt; eval(b, env, s) match {
         case (AddressV(a), s1)
           =&gt; eval(e, env, s1) match {
                case (ev, s2) =&gt; (ev, s2.updated(a, ev))
              }
         case _ =&gt; sys.error(&quot;can only set boxes&quot;)
       }

  /* OpenBox uses the same two-step process but does not update the
   * store.  */
  case OpenBox(b: Exp)
    =&gt; eval(b, env, s) match {
         case (AddressV(a), s1) =&gt; (s1(a), s1)
         case _                 =&gt; sys.error(&quot;can only open boxes&quot;)
       }
}

/**
From an implementation point of view, our interpreter has the problem that nothing is ever removed from the store.
One possibility would be to add an operation &quot;removeBox&quot; or the like to the language, but this would lead to dangling pointers
and all the* problems associated with manual memory management.
Our model of stores is sufficient to illustrate how modern languages deal with memory management: by garbage collection.
Garbage collectors automatically reclaim memory that is no longer referenced from within the active part of the computation.
We can* model a (naive) mark-and-sweep garbage collector as follows:
*/

def gc(env: Env, store:Store) : Store = {

  def allAddrInVal(v: Value) : Set[Address] = v match {
    case AddressV(a)      =&gt; Set(a)
    case NumV(_)          =&gt; Set.empty
    case ClosureV(f, env) =&gt; allAddrInEnv(env)
  }

  def allAddrInEnv(env: Env) : Set[Address] =
    env.values.map(allAddrInVal _).fold(Set.empty)(_ union _)

  def mark(seed: Set[Address]) : Set[Address] = {
    val newAddresses = seed.flatMap(ad =&gt; allAddrInVal(store(ad)))
    if (newAddresses.subsetOf(seed)) seed
    else mark(seed union newAddresses)
  }

  val marked = mark(allAddrInEnv(env)) // mark ...
  store.view.filterKeys(marked(_)).toMap           // and sweep!
}

val teststore = Map(
  6  -&gt; NumV(42),
  7  -&gt; NumV(6),
  8  -&gt; AddressV(6),
  9  -&gt; AddressV(7),
  10 -&gt; ClosureV(Fun(&quot;x&quot;, &quot;y&quot;), Map(&quot;y&quot; -&gt; AddressV(8)))
)

/*
10 -&gt; 8 -&gt; 6
      9 -&gt; 7        */

assert(gc(Map(&quot;a&quot; -&gt; AddressV(10)), teststore) == teststore - 7 - 9)

/**
Note that garbage collectors only _approximate_ the set of semantically disposable store entities. Even with garbage collectors,
applications may very well suffer from memory leaks. The approximation should be _safe_, in the sense that a datum is never reclaimed
when it is used by subsequent computations. Furthermore, it must reclaim enough garbage to be actually useful. Reachability has turned
out to be a rather useful (and sound) approximation of semantic disposability. Garbage collectors must also be efficient.
Efficiency of GC is a huge research topic that we are not going to discuss. One efficiency problem with garbage collectors based on
reachability that we want to mention is the &quot;stop-the-world&quot; phenomenon.
 */
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../09-recursive-functions/recursive-functions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../11-garbage-collection/garbage-collection.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../09-recursive-functions/recursive-functions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../11-garbage-collection/garbage-collection.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../questionnaire.js"></script>
    </body>
</html>
