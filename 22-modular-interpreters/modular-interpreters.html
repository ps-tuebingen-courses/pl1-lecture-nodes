<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Modular Interpreters - Programming Languages I</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Lecture notes for the Programming Languages I lecture at the University of TÃ¼bingen">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../preface.html">Preface</a></li><li class="chapter-item expanded affix "><li class="part-title">Introduction</li><li class="chapter-item expanded "><a href="../01-intro/intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../02-scala-basics/scala-basics.html"><strong aria-hidden="true">2.</strong> Scala Basics</a></li><li class="chapter-item expanded affix "><li class="part-title">Arithmetic Expressions</li><li class="chapter-item expanded "><a href="../03-arithmetic-expressions/arithmetic-expressions.html"><strong aria-hidden="true">3.</strong> Arithmetic Expressions (AE)</a></li><li class="chapter-item expanded "><a href="../04-desugaring/desugaring.html"><strong aria-hidden="true">4.</strong> Desugaring</a></li><li class="chapter-item expanded "><a href="../05-name-binding/name-binding.html"><strong aria-hidden="true">5.</strong> Name Binding (WAE)</a></li><li class="chapter-item expanded "><a href="../06-first-order-functions/first-order-functions.html"><strong aria-hidden="true">6.</strong> First Order Functions (F1WAE)</a></li><li class="chapter-item expanded "><a href="../07-higher-order-functions/higher-order-functions.html"><strong aria-hidden="true">7.</strong> Higher Order Functions (FAE)</a></li><li class="chapter-item expanded "><a href="../08-lazy-evaluation/lazy-evaluation.html"><strong aria-hidden="true">8.</strong> Lazy Evaluation (LCFAE)</a></li><li class="chapter-item expanded "><a href="../09-recursive-functions/recursive-functions.html"><strong aria-hidden="true">9.</strong> Recursive Functions (RCFAE)</a></li><li class="chapter-item expanded "><a href="../10-mutation/mutation.html"><strong aria-hidden="true">10.</strong> Mutation (BCFAE)</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Topics 1</li><li class="chapter-item expanded "><a href="../11-garbage-collection/garbage-collection.html"><strong aria-hidden="true">11.</strong> Garbage Collection</a></li><li class="chapter-item expanded "><a href="../12-meta-interpretation/meta-interpretation.html"><strong aria-hidden="true">12.</strong> Syntactic and Meta Interpretation</a></li><li class="chapter-item expanded "><a href="../13-church-encoding/church-encoding.html"><strong aria-hidden="true">13.</strong> Church Encodings</a></li><li class="chapter-item expanded "><a href="../14-object-algebras/object-algebras.html"><strong aria-hidden="true">14.</strong> Object Algebras</a></li><li class="chapter-item expanded affix "><li class="part-title">Continuations</li><li class="chapter-item expanded "><a href="../15-continuations-1/continuations-1.html"><strong aria-hidden="true">15.</strong> Continuations 1</a></li><li class="chapter-item expanded "><a href="../16-continuations-2/continuations-2.html"><strong aria-hidden="true">16.</strong> Continuations 2</a></li><li class="chapter-item expanded "><a href="../17-first-class-continuations/first-class-continuations.html"><strong aria-hidden="true">17.</strong> First Class Continuations</a></li><li class="chapter-item expanded "><a href="../18-letcc/letcc.html"><strong aria-hidden="true">18.</strong> LetCC</a></li><li class="chapter-item expanded "><a href="../19-shift-reset/shift-reset.html"><strong aria-hidden="true">19.</strong> ShiftReset</a></li><li class="chapter-item expanded affix "><li class="part-title">Monads</li><li class="chapter-item expanded "><a href="../20-monads-intro/monads-intro.html"><strong aria-hidden="true">20.</strong> Monads Intro</a></li><li class="chapter-item expanded "><a href="../21-io-monad/io-monad.html"><strong aria-hidden="true">21.</strong> IO Monad</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Topics 2</li><li class="chapter-item expanded "><a href="../22-modular-interpreters/modular-interpreters.html" class="active"><strong aria-hidden="true">22.</strong> Modular Interpreters</a></li><li class="chapter-item expanded "><a href="../23-monadic-reflection/monadic-reflection.html"><strong aria-hidden="true">23.</strong> Monadic Reflection</a></li><li class="chapter-item expanded "><a href="../24-defunctionalization/defunctionalization.html"><strong aria-hidden="true">24.</strong> Defunctionalization</a></li><li class="chapter-item expanded affix "><li class="part-title">Type Systems</li><li class="chapter-item expanded "><a href="../25-type-systems/type-systems.html"><strong aria-hidden="true">25.</strong> Type Systems</a></li><li class="chapter-item expanded "><a href="../26-stlc/stlc.html"><strong aria-hidden="true">26.</strong> Simply Typed Lambda Calculus (STLC)</a></li><li class="chapter-item expanded "><a href="../27-type-inference/type-inference.html"><strong aria-hidden="true">27.</strong> Type Inference</a></li><li class="chapter-item expanded affix "><a href="../furtherreading.html">Further Reading</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Programming Languages I</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ps-tuebingen-courses/pl1-lecture-notes" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/ps-tuebingen-courses/pl1-lecture-notes/blob/master/out/22-modular-interpreters/modular-interpreters.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="modular-interpreters"><a class="header" href="#modular-interpreters">Modular Interpreters</a></h1>
<pre><code class="language-scala">import scala.language.higherKinds
import scala.language.implicitConversions
import scala.language.reflectiveCalls

/**
A Monad Library
================
 A Monad library in Scala. Monad libraries like
in scalaz and cats (for Scala) or the Haskell
standard library look similar. */
trait Monad {
    type M[_] // this time we treat M as a type member and not as type parameter
              // because it leads to shorter type signatures
    def unit[A](a: A) : M[A]
    def bind[A,B](m: M[A], f: A =&gt; M[B]) : M[B]
    implicit def monadicSyntax[A](m:M[A]) = new {
        def map[B](f: A =&gt; B) = bind(m, (x:A) =&gt; unit(f(x)))
        def flatMap[B](f: A =&gt; M[B]) : M[B] = bind(m,f)
    }
}
/**
  We formulate concrete monads in the form of abstract interfaces first.
  The idea of those interfaces is that it should be possible to use
  the monad only in terms of that interface, without knowing anything
  about M. The advantage of this approach is that it enables us to
  compose monads. M changes in every composition of monads. For instance,
  when composing the list monad and the option monad, then
  M[X] = Option[List[X]] or M[X]=List[Option[X]].
  By keeping M abstract and using it only via the interfaces, &quot;client code&quot;
  does not need to depend on the particular composition of monads.
  The Reader (or Environment) monad captures computations that depend
  on an environment of type R.
  The ask function yields the current environment, the local function
  is used to transform the environment in a subcomputation a by an
  environment transformer f. */ 
trait ReaderMonad extends Monad {
    type R
    def ask: M[R]
    def local[A](f: R =&gt; R, a: M[A]) : M[A]
}

/** The standard implementation of the Reader monad: */
trait ReaderMonadImp extends ReaderMonad {
    type M[X] = R =&gt; X
    def unit[A](a: A) : M[A] = r =&gt; a
    def bind[A,B](m: M[A], f: A =&gt; M[B]) : M[B] = r =&gt; f(m(r))(r)
    def ask : M[R] = identity
    def local[A](f: R =&gt; R, a: M[A]) : M[A] = r =&gt; a(f(r))
}

/** An example of using the reader monad to propagate an environment
of type Int through a computation. */
object ReaderExample extends ReaderMonadImp {
    type R = Int
    def example : M[Int] = for { x &lt;- ask } yield (x+1)
    def example2 : M[Int] = local( r =&gt; 99, example)
}

/** A more useful example where we use the reader monad
to propagate a mapping from identifiers to boolean values
in an interpreter for boolean formulas. */

object ReaderExample2 extends ReaderMonadImp {
    trait Exp
    case class Id(x: String) extends Exp
    case class And(l: Exp, r: Exp) extends Exp
    case class Or(l: Exp, r: Exp) extends Exp
    type R = Map[String,Boolean]

    // note that the signature of eval is identical to
    // def eval(e: Exp) : Map[String,Boolean] =&gt; Boolean
    // that is, we curry eval to make it applicable to
    // the reader monad.

    def eval(e: Exp): M[Boolean] = e match {
        case Id(x) =&gt; for {env &lt;- ask } yield env(x)
        case And(l,r) =&gt; for {
            x &lt;- eval(l)
            y &lt;- eval(r)
        } yield (x &amp;&amp; y)
        // the implementation of the &quot;And&quot; case is semantically
        // equivalent to this code:
        //case And(l,r) =&gt; env =&gt; {
        //    val x = eval(l)(env)
        //    val y = eval(r)(env)
        //    x &amp;&amp; y
        //}
        // However, the monadic code is more abstract (and hence
        // more reusable) because it is not coupled to the 
        // concrete M
        case Or(l,r) =&gt; for {
            x &lt;- eval(l)
            y &lt;- eval(r)
        } yield (x || y)
    }
}

trait StateMonad extends Monad {
    type S 
    def getState : M[S]
    def putState(s: S) : M[Unit]
}

trait StateMonadImp extends StateMonad {
    type M[A] = S =&gt; (A,S)
    def unit[A](a: A) : M[A] = (s: S) =&gt; (a,s)
    def bind[A,B](m: M[A], f: A =&gt; M[B]) : M[B] = (s: S) =&gt; {
        val (a,s2) = m(s)
        f(a)(s2)
    }
    def getState : M[S] = s =&gt; (s,s)
    def putState(s: S) : M[Unit] = _ =&gt; ((),s)
}

// The continuation monad provides a method callcc,
// which reifies the current continuation k : A =&gt; M[B]
trait ContinuationMonad extends Monad {
  def callcc[A,B](f : (A =&gt; M[B]) =&gt; M[A]) : M[A]
}

// End of Monad Interfaces

// Now we provide implementations of the monad interfaces.

// The identity monad, which is the end of each transformer chain
trait IdentityMonad extends Monad {
  type M[A] = A
  def unit[A](a: A) : M[A] = a
  def bind[A,B](m: M[A], f: A =&gt; M[B]) = f(m)
}

object IdentityMonad extends IdentityMonad

// We organize most other monads as monad _transformers_.
// A monad transformer is parameterized with another monad.
// The monads are organized in a chain. Operations of 
// &quot;inner&quot; monads must be lifted to top-level operations.

trait MonadTransformer extends Monad {
  protected val m : Monad
}  

// The Reader monad transformer. We provide some convenient
// functions lift, lift2 etc. to lift functions from the inner monad.
// Note that M[X] = R =&gt; m.M[X] instead of M[X] = R =&gt; X (as for
// the non-transformer version of the reader monad).
// The correct implementation of the interface methods follows from
// this type equation.

trait ReaderT extends MonadTransformer with ReaderMonad {
  type R
  override type M[X] = R =&gt; m.M[X]
  override def unit[A](a: A) : M[A] = r =&gt; m.unit(a)
  override def bind[A,B](x: M[A], f: A =&gt; M[B]) : M[B] = r =&gt; m.bind(x(r), (n:A) =&gt; f(n)(r))
  override def ask : M[R] = r =&gt; m.unit(r)
  override def local[A](f: R =&gt; R, a: M[A]) : M[A] = r =&gt; a(f(r))
  protected implicit def lift[A](x: m.M[A]) : M[A] = r =&gt; x
  protected implicit def lift2[A,B](x: A =&gt; m.M[B]) : A =&gt; M[B] = a =&gt; lift(x(a))
  protected implicit def lift3[A,B,C](x: (A =&gt; m.M[B]) =&gt; m.M[C]) : (A =&gt; M[B]) =&gt; M[C] = f =&gt; r =&gt; x( (a: A) =&gt; f(a)(r)) 
  protected implicit def lift4[A,B,C,D](x: ((A =&gt; m.M[B]) =&gt; m.M[C]) =&gt; m.M[D]) : ((A =&gt; M[B]) =&gt; M[C]) =&gt; M[D] = f =&gt; r =&gt; x( (a: A =&gt; m.M[B]) =&gt; f(lift2(a))(r)) 
}

// The original Reader monad can be reconstructed by composing ReaderT with the identity monad.

trait ReaderMonadImpl extends ReaderT {
  val m = IdentityMonad
}

/* We do not need this because we have just synthesized it.
trait ReaderMonadImpl extends ReaderMonad {
  type M[X] = R =&gt; X
  def unit[A](a: A) : M[A] = r =&gt; a
  def bind[A,B](m: M[A], f: A =&gt; M[B]) : M[B] = r =&gt; f(m(r))(r)
  def ask : M[R] = identity
  def local[A](f: R =&gt; R, a: M[A]) : M[A] = (r) =&gt; a(f(r))
}  
*/

// The design of StateT is similar to that of ReaderT
trait StateT extends MonadTransformer with StateMonad {
  type M[A] = S =&gt; m.M[(A,S)]
  override def unit[A](a: A) : M[A] = (s: S) =&gt; m.unit(a,s)
  override def bind[A,B](x: M[A], f: A =&gt; M[B]) : M[B] = (s: S) =&gt; {
     m.bind[(A,S),(B,S)](x(s), { case (a,s2) =&gt; f(a)(s2)})
  }
  override def getState : M[S] = s =&gt; m.unit((s,s))
  override def putState(s: S) : M[Unit] = _ =&gt; m.unit(((),s))
}

// and again we can reconstruct the ordinary state monad.

trait StateMonadImpl extends StateT {
  val m = IdentityMonad
}  

/* We do not need this because we have just synthesized it.
trait StateMonadImpl extends StateMonad {
  type M[A] = S =&gt; (A,S)
  def unit[A](a: A) : M[A] = (s: S) =&gt; (a,s)
  def bind[A,B](m: M[A], f: A =&gt; M[B]) : M[B] = (s: S) =&gt; {
     val (a,s2) = m(s)
	 f(a)(s2)
  }
  def getState : M[S] = s =&gt; (s,s)
  def putState(s: S) : M[Unit] = _ =&gt; ((),s)
}*/


// We could also synthesize ContinuationMonadImpl from a ContT
// just as we did for ReaderMonadImpl and StateMonadImpl
// But for simplicity we only present the ordinary 
// continuation monad here.

trait ContinuationMonadImpl extends ContinuationMonad {
  type T
  type M[A] = (A =&gt; T) =&gt; T
  override def unit[A](a: A) : M[A] = k =&gt; k(a)
  override def bind[A,B](m: M[A], f: A =&gt; M[B]): M[B] = k =&gt; m( a =&gt; f(a)(k))
  override def callcc[A,B](f : (A =&gt; M[B]) =&gt; M[A]) : M[A] = k =&gt; f(a =&gt; _ =&gt; k(a))(k)
}

// The composition of the Reader monad and some continuation monad.
trait ReaderContinuationMonadForwarder extends ReaderT with ContinuationMonad {
  val m : ContinuationMonad
  override def callcc[A,B](f : (A =&gt; M[B]) =&gt; M[A]) : M[A] = (m.callcc[A,B] _)(f) // call to lift4 inserted automatically                                                                                    
}

// The composition of the Reader monad and the continuation monad implementation.
trait ReaderContinuationMonadImpl extends ReaderContinuationMonadForwarder {
  type T
  val m = new ContinuationMonadImpl { type T = ReaderContinuationMonadImpl.this.T }
}  

// Composition of reader monad with some state monad.
trait ReaderStateMonadForwarder extends ReaderT with StateMonad {
  val m: StateMonad { type S = ReaderStateMonadForwarder.this.S }
  override def getState : M[S] = m.getState
  override def putState(s: S) : M[Unit] = m.putState(s)
}

// Composition of reader monad with StateMonadImpl
trait ReaderStateMonadImpl extends ReaderStateMonadForwarder {
  val m = new StateMonadImpl { type S = ReaderStateMonadImpl.this.S }
}

/**
Now we use the monad library to modularize the interpreters of
the various language variants we have seen so far. */

trait Expressions extends Monad {
  abstract class Value 
  abstract class Exp {
    def eval : M[Value]
  }  
}

trait Numbers extends Expressions {
  case class NumV(n: Int) extends Value
}

trait Arithmetic extends Numbers {
  case class Num(n: Int) extends Exp {
    def eval = unit(NumV(n))
  }
  implicit def num2exp(n: Int) = Num(n)
  
  case class Add(lhs: Exp, rhs: Exp) extends Exp {
    def eval = for { 
	             l &lt;- lhs.eval 
				 r &lt;- rhs.eval
			   } yield (l,r) match {
			                case (NumV(v1), NumV(v2)) =&gt; NumV(v1+v2)
							case _ =&gt; sys.error(&quot;can only add numbers&quot;)
						}
  }		
}

trait If0 extends Numbers {  
  case class If0(cond: Exp, thenExp: Exp, elseExp: Exp) extends Exp {
    def eval = for {
	             c &lt;- cond.eval
	             res &lt;- c match { case NumV(0) =&gt; thenExp.eval
	                              case _ =&gt; elseExp.eval }
	           } yield res 
  }
}

trait Functions extends Expressions with ReaderMonad {
  type Env = Map[String,Value]
  override type R = Env

  case class ClosureV(f: Fun, env: Env) extends Value
  case class Fun(param: String, body: Exp) extends Exp {
    def eval = for { env &lt;- ask } yield ClosureV(this, env)
  }	
  case class App(f: Exp, a: Exp) extends Exp {
    def eval = for {
	            fv &lt;- f.eval
				av &lt;- a.eval
				res &lt;- fv match { case ClosureV(fun,cenv) =&gt; local( env =&gt; cenv + (fun.param -&gt; av), fun.body.eval) }
		       } yield res

  }
  case class Id(x: String) extends Exp {
    def eval = for {
	             env &lt;- ask
			   } yield env(x)
  }
  implicit def id2exp(x: String) = Id(x)
  def wth(x: String, xdef: Exp, body: Exp) : Exp = App(Fun(x,body),xdef)
}  


trait Boxes extends Expressions with StateMonad  {
  override type S = Store
  type Store = Map[Address,Value]

  type Address = Int
  var _nextAddress = 0

  def nextAddress : Address = {
    _nextAddress += 1
    _nextAddress
  }
  
  case class AddressV(a: Address) extends Value

  case class NewBox(e: Exp) extends Exp {
    def eval = {
	  val a = nextAddress
	  for {
	    v &lt;- e.eval
		s &lt;- getState
		_ &lt;- putState(s + (a -&gt; v))
	  } yield AddressV(a)
    }
  }
  case class SetBox(b: Exp, e: Exp) extends Exp {
     def eval = 
       for {
          box &lt;- b.eval
          ev  &lt;- e.eval
          s   &lt;- getState
          _   &lt;- putState(box match { case AddressV(a) =&gt; s.updated(a,ev) })
	   } yield ev
  }
  
  
  case class OpenBox(b: Exp) extends Exp {
    def eval = for {
	             bv &lt;- b.eval
	             s  &lt;- getState
			   } yield (bv match { case AddressV(a) =&gt; s(a) })
  }
  case class Seq(e1: Exp, e2: Exp) extends Exp {
    def eval = bind(e1.eval,(_:Value) =&gt; e2.eval)
  }
  
}

trait Letcc extends Expressions with ContinuationMonad with ReaderMonad{
  override type R = Map[String,Value]
  
  // We introduce a new application form CApp instead of using App because we cannot extend App
  case class CApp(f: Exp, a: Exp) extends Exp {
    override def eval : M[Value] = 
        for {
           fv &lt;- f.eval
           av &lt;- a.eval
           res &lt;- fv match { case ContV(f) =&gt; f(av) }
         } yield res
  }
  case class Letcc(param: String, body: Exp) extends Exp {
    override def eval : M[Value] = callcc[Value,Value](k =&gt; local( env =&gt; env + (param -&gt; ContV(k)), body.eval))
  }  
  case class ContV(f: Value =&gt; M[Value]) extends Value
}


// Let's compose together some languages!

object AE extends Arithmetic with IdentityMonad {
  val aetest = Add(1,Add(2,3))
}
assert(AE.aetest.eval == AE.NumV(6)) 

object FAELang extends Functions with Arithmetic with ReaderMonadImpl {
  val faetest = App(Fun(&quot;x&quot;, Add(&quot;x&quot;, 1)), Add(2,3))
  assert(faetest.eval(Map.empty) == NumV(6))
}
object BCFAE extends Boxes with Arithmetic with Functions with If0 with ReaderStateMonadImpl {
  val test = wth(&quot;switch&quot;, NewBox(0),
                wth(&quot;toggle&quot;, Fun(&quot;dummy&quot;, If0(OpenBox(&quot;switch&quot;),
                                          Seq(SetBox(&quot;switch&quot;, 1), 1),
                                          Seq(SetBox(&quot;switch&quot;, 0), 0))),
                             Add(App(&quot;toggle&quot;,42), App(&quot;toggle&quot;,42))))  
}  

assert(BCFAE.test.eval(Map.empty)(Map.empty)._1 == BCFAE.NumV(1))

object FAEwLetcc extends Arithmetic with Functions with If0 with Letcc with ReaderContinuationMonadImpl {
  override type T = Value
  val testprog = Add(1, Letcc(&quot;k&quot;, Add(2, CApp(&quot;k&quot;, 3))))  
}  

assert(FAEwLetcc.testprog.eval(Map.empty)(identity) == FAEwLetcc.NumV(4))
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../21-io-monad/io-monad.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../23-monadic-reflection/monadic-reflection.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../21-io-monad/io-monad.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../23-monadic-reflection/monadic-reflection.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
